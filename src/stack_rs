use std::mem::MaybeUninit;

const L: usize = 1024;

pub struct Stack {
    xs: [MaybeUninit<(u64, u64, u64, u64)>; L],
    sz: usize
}

#[must_use]
#[inline(always)]
pub const fn uninit_array<const N: usize, T>() -> [MaybeUninit<T>; N] {
    unsafe { MaybeUninit::<[MaybeUninit<T>; N]>::uninit().assume_init() }
}

impl Stack {
    pub fn new() -> Self {
        Self { xs: uninit_array(), sz: 0 }
    }
    
    pub fn push(&mut self, item: (u64, u64, u64, u64)) -> bool {
        if (self.sz + 1) <= L {
            self.xs[self.sz].write(item);
            self.sz += 1;
            true
        } else {
            false
        }
    }
    
    pub fn pop(&mut self) -> Option<(u64, u64, u64, u64)> {
        (self.sz > 0).then(|| {
            self.sz -= 1;
            unsafe {
                self.xs[self.sz].assume_init()
            }
        })
    }
}